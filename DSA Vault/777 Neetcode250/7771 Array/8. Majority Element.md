**Topics:** [[Array]] [[HashMap]]
**Level:** Easy

---
# Majority Element

Given an array `nums` of size `n`, return the **majority element**.
The majority element is the element that appears more than `⌊n / 2⌋` times in the array. You may assume that the majority element always exists in the array.

**Example 1:**
```java
Input: nums = [5,5,1,1,1,5,5]

Output: 5
```

**Example 2:**
```java
Input: nums = [2,2,2]

Output: 2
```

**Constraints:**
- `1 <= nums.length <= 50,000`
- `-1,000,000,000 <= nums[i] <= 1,000,000,000`

**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?

**Solution(My Approach):**
```java
class Solution {
    public int majorityElement(int[] nums) {
        if(nums.length==0) return 0;
        int majority_length=nums.length/2;
        int occurrence=0;

        for(int i=0;i<nums.length;i++){
        for(int j=i;j<nums.length;j++){
            if(nums[i]==nums[j]){
                occurrence++;
            }
        }

        if(occurrence>majority_length){
            return nums[i];
        }else{
            occurrence=0;
        }
        }

        throw new IllegalArgumentException("no match found");
    }
}

```

| Aspect    | Complexity |
| --------- | ---------- |
| **Time**  | **O(n²)**  |
| **Space** | **O(1)**   |
**Solution(via HashMap):**
```java
class Solution {
    public int majorityElement(int[] nums) {
        if(nums.length==0) return 0;
        int n=nums.length/2;
        Map<Integer,Integer> map= new HashMap<>();
        for(int i : nums){
            map.put(i, map.getOrDefault(i , 0)+ 1);
        }

        for(int i: map.keySet()){
            if(map.get(i)>n){
                return i;
            }
        }
        throw new IllegalArgumentException("no match found");
    }
}
```

| Aspect    | Complexity |
| --------- | ---------- |
| **Time**  | **O(n²)**  |
| **Space** | **O(1)**   |
**Optimal Approach(Boyer Moore Majority Voting Algorithm):**
```java
class Solution {
    public int majorityElement(int[] nums) {
        if(nums.length==0) return 0;
        int candidate=nums[0];
        int count=0;

        for(int i: nums){
            if(i == candidate){
                count++;
            }else{
                count --;
                if(count==0){
                    candidate=i;
                    count++;
                }
            }
        }
        return candidate;
    }
}

```

| Aspect    | Complexity |
| --------- | ---------- |
| **Time**  | **O(n)**   |
| **Space** | **O(1)**   |
